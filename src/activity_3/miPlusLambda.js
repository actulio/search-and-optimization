import { getRandomArray } from '../utils/utils.js';
import '../utils/typedefs.js';

/**
 * @deprecated Use optimizedMiPlusLambda instead
 */
export function miPlusLambda(params, options, mutate, fitness) {
  const { mi, lambda } = params;
  const { min, max, D, iterations } = options;

  if (mi > lambda) return [];

  let P = [];
  let Q = [];
  let best = undefined;

  for (let i = 0; i < lambda; i++) {
    P.push(getRandomArray(min, max, { isInt: false }));
  }

  for (let i = 0; i < iterations; i++) {
    let assessedFitness = [];
    for (let Pi of P) {
      assessedFitness.push(fitness(Pi));
      if (best === undefined || fitness(Pi) < fitness(best)) {
        best = Pi;
      }
    }

    // Q ← the µ individuals in P whose Fitness( ) are greatest TODO

    for (let Qi of Q) {
      for (let k = 0; k < Math.round(lambda / mi); k++) {
        P.push(mutate([...Qi]));
      }
    }
  }

  return best;
}

/**
 * @description Algorithm 19: The (mi + lambda) Evolution Strategy
 * @param  {Object} params object containing variable options
 * @param  {Number} params.mi number of parents selected
 * @param  {Number} params.lambda number of children generated by the parents
 * @param  {Options} options object containing options
 * @param  {Function} mutate the mutation function
 * @param  {Function} fitness the fitness/quality function
 */
export function optimizedMiPlusLambda(params, options, mutate, fitness) {
  const { mi, lambda } = params;
  const { min, max, D, iterations } = options;

  if (lambda < mi) return Array(100).fill(0);

  let P = [];
  let Q = [];
  let counter = 0;

  for (let i = 0; i < lambda; i++) {
    P.push({ arr: getRandomArray(min, max, D, { isInt: false }), fitness: null });
  }
  let best = { arr: P[0].arr, fitness: fitness(P[0].arr) };

  do {
    P.forEach((pi, idx) => {
      if (pi.fitness === null) {
        P[idx].fitness = fitness(pi.arr);
        counter += 1;
      }
      if (pi.fitness < best.fitness) {
        best = { arr: [...pi.arr], fitness: pi.fitness };
      }
    });

    P = P.sort((a, b) => a.fitness - b.fitness).slice(0, mi);
    Q = [...P];

    for (let Qi of Q) {
      for (let k = 0; k < Math.round(lambda / mi); k++) {
        P.push({ arr: mutate([...Qi.arr]), fitness: null });
      }
    }
  } while (counter < iterations);

  return best;
}
